在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 

示例 1：

输入：nums = [3,4,3,3]
输出：4
示例 2：

输入：nums = [9,1,7,9,7,9,7]
输出：1

状态机和位运算

初始的时候在状态 0 （有 0 个 1），然后如果下一个数这一位是 1，就进入状态 1（有 1 个 1），接着如果下一个数这一位是 1，就进入状态
2（有 2 个 1），接着如果下一个数这一位是 1，就进入状态 3（有 3 个 1），最后如果再来了一个数这一位还是 1，就说明是一个新的数了，
等价于回到了状态 1。而每个状态如果来的数这一位是 0 ，都会保持状态不变。

当然这个自动机还可以简化，注意观察可以发现状态 3 和状态 0 是等价的（输入 0 都保持不变，输入 1 都会进入状态 1）。所以我们将状态1
和状态 3 合并为一个状态 0 ，得到如下的状态自动机：

因为一共有三个状态，所以我们需要用两个变量来表示状态。用 once 表示是否在状态 1，用 twice 来表示是否在状态 2 。那么两个变量都为0
就表示在状态 0 。然后可以得到如下的状态转移表：

注意观察 once 只有两种情况下转移后为 1 。一种是 once=0, twice=0, x=1 ，另一种是 once=1, twice=0, x=0 。其他所有情况下 once 都转移为
0 。这两种情况都满足 x^once=1 并且 twice=0 ，所以 once 的转移就是 once = (x^once) & (~twice) 。

同理，观察 twice 只有两种情况下转移后为 1 。一种是 once=1, twice=0, x=1 ，另一种是 once=0, twice=1, x=0 。其他所有情况下twice
都转移为 0 。这两种情况都满足 x^twice=1 并且 once^twice=1 ，所以 twice 的转移就是 twice = (x^twice) & (once^twice) 。但是！！！
once 已经抢先一步转移过了，所以值已经变掉了，一个解决方法就是用临时变量保存一下前一个状态的 once 值。另一个方法就是，这两种情况下，
once 都会转移到 0 ，所以判断条件直接用转移后的 once=0 就行了，随后转移就是 twice = (x^twice) & (~once) 。

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret;
        int s1 = 0;
        int s2 = 0;
        for ( auto a : nums ) {
            s1 = ~s2&(s1^a);
            s2 = ~s1&(s2^a);
        }
        return s1;
    }
};
