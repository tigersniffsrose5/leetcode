数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

 

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1:

输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2


class Solution {
public:
    int majorityElement(vector<int>& nums) {

        //方法1：排序后中间的元素一定是出现超过一半的数字
        sort(nums.begin(),nums.end());
        return nums[nums.size()/2];

        //方法2：哈希表
        unordered_map<int,int> mp;
        
        for ( auto it : nums ) {

            mp[it]++;
            if(mp[it]>nums.size()/2) return it;
        
        }

        return 0;

        //3:摩尔投票法： 核心理念为 票数正负抵消 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。
推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0 。

推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a) 个数字的 票数和一定仍 >0 ，即后 (n−a) 个数字的 众数仍为 x 。

根据以上推论，假设数组首个元素 n1 为众数，遍历并统计票数。当发生 票数和 =0 时，剩余数组的众数一定不变 ，这是由于：

当 n1 = x： 抵消的所有数字，有一半是众数 x 。
当 n1 != x ： 抵消的所有数字，少于或等于一半是众数 x。
利用此特性，每轮假设发生 票数和 =0 都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数。

算法流程:
初始化： 票数统计 votes = 0 ， 众数 x；
循环： 遍历数组 nums 中的每个数字 num ；
当 票数 votes 等于 0 ，则假设当前数字 num 是众数；
当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 ；
返回值： 返回 x 即可；
        
        int x = 0, votes = 0;
        
        for ( int num : nums ) {

            if ( votes == 0 )
                x = num;

            votes += num == x ? 1 : -1;
        
        }

        return x;

    }

};
